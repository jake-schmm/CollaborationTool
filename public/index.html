<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Video Chat</title>
<!-- Font Awesome -->
<link
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
  rel="stylesheet"
/>
<!-- Google Fonts -->
<link
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
  rel="stylesheet"
/>
<!-- MDB -->
<link
  href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/7.2.0/mdb.min.css"
  rel="stylesheet"
/>
<script src="/socket.io/socket.io.js"></script>
<style>
    * {
        box-sizing: border-box;
    }
    .box {
    width: 100%; /* Ensures the video fills the container */
    height: auto; /* Maintain aspect ratio */
    display: block; /* Removes extra space below the video */
}

.videoBox {
    width: 46%; /* Width of each video box */
    padding: 15px; /* Padding around videos */
    margin: 1%; /* Space between video boxes */
    box-sizing: border-box; /* Includes padding and border in the width */
    position: relative; /* For absolute positioning of buttons */
}

.videoContainer {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around;
    align-items: flex-start; /* Align items at the start of the container */
}
video {
    background-color: white;
    border: 10px solid;
    padding: 15px;
}
.muteButton {
    margin-top: 1%;
}
    #topInputs {
        margin-top: 2%;
        margin-bottom: 2%;
        text-align: center;
    }
    .innerDiv {
        margin-top: 5%;
        margin: 0 auto;
    }
    #main {
        position: relative;
        width: 100%; /* Full width of the container */
        min-height: 100vh; /* Full height of the viewport */
        overflow: auto; /* Ensures no overflow from the pseudo-element */
    }

    #main::before {
        content: ""; /* Necessary for pseudo-elements */
        position: absolute;
        left: 0;
        width: 100%; /* Full width */
        height: 100vh; /* The height of the container */
        /*background: url('https://mdbcdn.b-cdn.net/img/new/fluid/city/018.jpg') no-repeat center center; */
        /*background: url('https://mdbootstrap.com/img/Photos/Others/images/76.jpg') no-repeat center center; */
        background: url('imgs/mqi1az5h.png') no-repeat center center;
        background-size: cover; /* Cover the area of the pseudo-element */
        z-index: -1; /* Places the background below the content */
    }

    #localVideo, #remoteVideo, .remoteVideo {
        background-color: white;
    }

    #roomName {
        padding: .375rem .75rem;
        font-size: 1rem;
        font-weight: 400;
        line-height: 1.6;
        color: var(--mdb-surface-color);
        appearance: none;
        background-color: var(--mdb-body-bg);
        background-clip: padding-box;
        border: var(--mdb-border-width) solid var(--mdb-border-color);
        border-radius: var(--mdb-border-radius);
    }

</style>
</head>
<body>
    <div id="log"></div>
    <div class="bg-image" id="main">
        <div id="topInputs">
            <h1 class="mb-3">Video Chat</h1>
            <div class="innerDiv">
                <input type="text" id="roomName" placeholder="Enter room name">
                <button class="btn btn-primary" id="joinRoom">Join Room</button>
                <div>Users in room: <span id="userCount">0</span></div>
                <br/>
            </div>
        </div>
        <div id="videoContainer" style="display: flex; flex-wrap: wrap; justify-content: space-around;">
            <div class="videoBox">
                <video class="box" id="localVideo" playsinline autoplay muted></video>
            </div>
            <!-- Repeat for each remote video -->
            <div class="videoBox">
                <video id='remoteVideo' class="box remoteVideo" playsinline autoplay muted></video>
                <button id='muteButton' class="muteButton btn btn-success">Unmute</button>
            </div>
        </div>
    </div>
<script>

// Mute and unmute
addMuteButtonEventListener('muteButton', 'remoteVideo');

function logMessage(message) {
    const log = document.getElementById('log');
    log.innerHTML += message + '<br/>';
}
function showToastNotification(message, duration = 3000) {
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.position = 'fixed';
    toast.style.top = '25%';
    toast.style.left = '50%';
    toast.style.transform = 'translateX(-50%)';
    toast.style.backgroundColor = 'rgba(0,0,0,0.7)';
    toast.style.color = 'white';
    toast.style.padding = '10px';
    toast.style.borderRadius = '5px';
    document.body.appendChild(toast);

    setTimeout(() => {
        document.body.removeChild(toast);
    }, duration);
}



function addMuteButtonEventListener(muteButtonId, remoteVideoId) {
    console.log("Hello");
    document.getElementById(muteButtonId).addEventListener('click', function() {
        console.log("TEST");
    var video = document.getElementById(remoteVideoId);
    var button = document.getElementById(muteButtonId);
    console.log(video.muted);
    console.log(button);
    if (video.muted) {
        video.muted = false;
        button.textContent = 'Mute';
        button.classList.remove('btn-success');
        button.classList.add('btn-danger');
    } else {
        video.muted = true;
        button.textContent = 'Unmute';
        button.classList.remove('btn-danger');
        button.classList.add('btn-success')
    }
    });
}

const socket = io(); // connect to socket.io server
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');

// Event listener to call matchVideoHeight when video1 starts playing
//localVideo.addEventListener('play', matchVideoHeight(remoteVideo, localVideo));
localVideo.addEventListener('play', () => {
    document.querySelectorAll('.remoteVideo').forEach(video => {
        matchVideoHeight(video, localVideo)
    });
});
// Event listener to call matchVideoHeight when video1 changes size (e.g., due to resizing the window)
window.addEventListener('resize', () => {
    document.querySelectorAll('.remoteVideo').forEach(video => {
        matchVideoHeight(video, localVideo)
    });
});

// Function to set the height of video2 to match video1
function matchVideoHeight(targetVideo, referenceVideo) {
    if (referenceVideo.readyState >= 2) {  // Ensures metadata is loaded
        targetVideo.style.height = `${referenceVideo.clientHeight}px`;
    } else {
        referenceVideo.addEventListener('loadedmetadata', () => {
            targetVideo.style.height = `${referenceVideo.clientHeight}px`;
        }, { once: true });
    }
}


        const peers = {};
      
        let currentRoomId;
        const roomUsers = {};
        let thisUserId;
         
           // Fetch userId from server
           socket.on('your-id', (id) => {
                    thisUserId = id;
                    console.log("User Id:" + thisUserId);
                });

        navigator.mediaDevices.getUserMedia({ video: true, audio: true })
            .then(stream => {
                localVideo.srcObject = stream;
                
                
                console.log(`Socket connected: ${socket.connected}`);
                socket.on('connect', () => {
                    console.log('Successfully connected to the server.');
                });
                
                socket.on('user-joined', (userId, id) => {
                    if (userId === thisUserId) return; // Don't create a peer connection for self
                    if(peers[userId]) return;
                    const pc = new RTCPeerConnection();
                    peers[userId] = pc;

                    stream.getTracks().forEach(track => {
                        pc.addTrack(track, stream);
                        console.log("Adding track to peer connection: " + track.label);
                        console.log("TRACK ENABLED: " + track.enabled);
                        console.log("TRACK READY: " + track.readyState);
                    });

                    setPeerConnectionHandlers(pc, userId);
                    pc.oniceconnectionstatechange = () => {
                    console.log(`ICE Connection State Change: ${pc.iceConnectionState}`);
                    if (pc.iceConnectionState === 'failed') {
                        console.log("ICE CONNECTION FAILED");
                    }
                    };
                });

                socket.on('receive-offer', (userId, offer) => {
                console.log("OFFER RECEIVED");
                const pc = new RTCPeerConnection();
                peers[userId] = pc;
                pc.candidateQueue = [];  // Initialize the candidate queue right after creating the peer connection

                stream.getTracks().forEach(track => {
                    pc.addTrack(track, stream);
                    console.log("Adding track to peer connection: " + track.label);
                });

                pc.ontrack = (event) => {
                    console.log("Stream received with tracks:", event.streams[0].getTracks());
                    event.streams[0].getTracks().forEach(track => {
                        console.log(`Track kind: ${track.kind}, enabled: ${track.enabled}, readyState: ${track.readyState}`);
                    });
                    let newVid = addVideoElement(userId, event);
                    console.log("Added video element after receiving offer");
                    // remoteVideo.srcObject = localVideo.srcObject; // this works. remoteVideo already exists
                    if(newVid) {
                        console.log("Adding event stream to new video");
                        console.log(event.streams[0]);
                        newVid.srcObject = event.streams[0];
                    }
                    

                };

                pc.onicecandidate = event => {
                    if (event.candidate) {
                        console.log(`Sending ICE candidate for ${userId}`);
                        const roomId = document.getElementById('roomName').value;
                        socket.emit('send-ice-candidate', event.candidate, roomId, userId);
                    }
                };

                pc.setRemoteDescription(new RTCSessionDescription(offer)).then(() => {
                    // Process any queued ICE candidates
                    while (pc.candidateQueue && pc.candidateQueue.length > 0) {
                        const candidate = pc.candidateQueue.shift();
                        pc.addIceCandidate(new RTCIceCandidate(candidate)).then(() => {
                            console.log(`Processed queued ICE candidate for ${userId}`);
                        }).catch(e => {
                            console.error(`Error processing queued ICE candidate for ${userId}: `, e);
                        });
                    }
                    return pc.createAnswer();
                }).then(answer => {
                    return pc.setLocalDescription(answer).then(() => {
                        return answer; // Make sure to return the answer to the next .then block
                    });
                }).then(answer => { // Now answer is available here as it was returned from the previous .then block
                    const roomId = document.getElementById('roomName').value;
                    console.log(`Answer created and local description set for ${userId}`);
                    socket.emit('send-answer', answer, roomId, userId);
                    console.log('sent answer');
                }).catch(error => {
                    console.error('Error during SDP negotiation: ', error);
                });
            });


                socket.on('receive-answer', (userId, answer) => {
                console.log('RECEIVE ANSWER');
                const pc = peers[userId];
                if (pc) {
                    console.log(`Setting remote description with answer for ${userId}`);
                    pc.setRemoteDescription(new RTCSessionDescription(answer))
                    .then(() => {
                        console.log("Remote description set successfully with answer");
                    })
                    .catch(e => {
                        console.error("Failed to set remote description with answer", e);
                    });
                }
            });


            socket.on('receive-ice-candidate', (userId, candidate) => {
                const pc = peers[userId];
                if (pc && pc.remoteDescription && pc.remoteDescription.type) {
                    pc.addIceCandidate(new RTCIceCandidate(candidate))
                    .then(() => console.log(`ICE candidate added for ${userId}`))
                    .catch(e => console.error(`Error adding ICE candidate for ${userId}: `, e));
                } else {
                    console.log(`ICE candidate received before setting remote description for ${userId}`);
                    pc.candidateQueue.push(candidate);
                }
            });
        }).catch(e => {
            console.error('Error setting up media devices');
        });

        function leaveRoom() {
            socket.emit('leave-room', 'someRoomId', socket.id);
        }

        
        function setPeerConnectionHandlers(pc, userId) {

            // Initialize the candidate queue on the peer connection object
             pc.candidateQueue = [];
             if (!pc.handlersSet) {
            pc.ontrack = (event) => {
                        addVideoElement(userId, event);
              
                    };

                    pc.onicecandidate = event => {
                        if (event.candidate) {
                        console.log(`Found ICE candidate for ${userId}`);
                        if (pc.remoteDescription && pc.remoteDescription.type) {
                            pc.addIceCandidate(new RTCIceCandidate(event.candidate));
                        } else {
                            console.log(`Queueing ICE candidate for ${userId}`);
                            pc.candidateQueue.push(event.candidate);
                        }
                    }
                    };
                    pc.handlersSet = true;
                }

                    pc.createOffer().then(offer => {
                        console.log(`Offer created: ${offer.sdp}`);
                        return pc.setLocalDescription(offer);
                    }).then(() => {
                        const roomId = document.getElementById('roomName').value;
                        console.log(`Sending offer to ${userId}`);
                        socket.emit('send-offer', pc.localDescription, roomId, userId);
                    }).catch(error => console.error('Error creating or sending offer: ', error))
        }

        document.getElementById('joinRoom').addEventListener('click', function() {
            const roomId = document.getElementById('roomName').value; // Get room name from input field
         
            socket.emit('join-room', roomId, thisUserId); // Emit join event to server with room name and new uuid as userId
            // note: if you ever want to use a database user ID here, would need to access from server 
            showToastNotification("Joined " + roomId + " successfully.");
            currentRoomId = roomId;
        });

        window.addEventListener("beforeunload", function(event) {
            leaveRoom(currentRoomId);
            removeVideoElement(thisUserId);
            socket.emit('pre-disconnect');
        });

        function leaveRoom(roomId) {
            socket.emit('leave-room', roomId, thisUserId);

            // Close and cleanup peer connections
            Object.keys(peers).forEach(userId => {
                closePeerConnection(peers[userId]);
                delete peers[userId];
            });
        }

        function closePeerConnection(pc) {
            if (pc) {
                pc.ontrack = null;
                pc.onicecandidate = null;
                pc.onnegotiationneeded = null;
                pc.oniceconnectionstatechange = null;
                pc.onsignalingstatechange = null;
                pc.onicegatheringstatechange = null;

                pc.getTransceivers().forEach(transceiver => {
                    transceiver.stop();
                });

                pc.close();
                if (pc.candidateQueue) {
                    pc.candidateQueue.length = 0;  // Clear the candidate queue
                }
                pc = null;
            }
        }

        
    function addVideoElement(userId, event) {
        let existingVideo = document.getElementById(`video_${userId}`);
        if(existingVideo) return;
        const videoContainer = document.getElementById('videoContainer');
        const newVideo = document.createElement('video');
        newVideo.id = `video_${userId}`;
        newVideo.autoplay = true;
        newVideo.defaultMuted = true; // necessary to add muted attribute when dynamically adding videos
        newVideo.muted = true;
        newVideo.playsInline = true;
        newVideo.classList.add('box', 'remoteVideo');
        
        const muteButton = document.createElement('button');
        muteButton.classList.add('btn', 'btn-success', 'muteButton');
        muteButton.innerText = 'Unmute'
        muteButton.id = `muteButton_${userId}`;
      
       
        newVideo.addEventListener('loadedmetadata', function() {
            matchVideoHeight(newVideo, localVideo);
        });
        // Event listener to call matchVideoHeight when video1 changes size (e.g., due to resizing the window)
        window.addEventListener('resize', () => matchVideoHeight(newVideo, localVideo));
        
        const videoBox = document.createElement('div');
        videoBox.classList.add('videoBox');
        videoBox.id = `videoBox_${userId}`;

        
        
        videoBox.appendChild(newVideo);
        videoBox.appendChild(muteButton);

        videoContainer.appendChild(videoBox);
        console.log(muteButton.id);
        
        addMuteButtonEventListener(muteButton.id, newVideo.id);
        // Additional setup, e.g., attaching media stream
      
        
        if (event.streams && event.streams[0]) {
            newVideo.srcObject = event.streams[0];
            console.log("Remote stream added");
        } else {
            let inboundStream = new MediaStream(event.track);
            newVideo.srcObject = inboundStream;
            console.log("Inbound stream");
        }
        console.log("Stream tracks:" + newVideo.srcObject.getTracks());
        newVideo.srcObject.getTracks().forEach((track) => {
            console.log("STREAM TRACK ENABLED: " + track.enabled);
            console.log("STREAM TRACK READY: " + track.readyState);
        });
        return newVideo;
    }

    function removeVideoElement(userId) {
        const videoBox = document.getElementById(`videoBox_${userId}`);
        if (videoBox) {
            videoBox.parentNode.removeChild(videoBox);
        }
    }
</script>

<!-- MDB -->
<script
  type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/7.2.0/mdb.umd.min.js"
></script>
</body>
</html>
